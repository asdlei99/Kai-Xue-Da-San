# 第一次阶段报告

### 一、概述

#### 1.1 设计题目

一个简单文法的编译器的设计与实现

#### 1.2 运行方法

软件：codeblock

编译器：GNU GCC compiler

#### 1.3 组内分工

金孟群（组长）：文法设计和扩展、创建符号表模块、语义分析（填写符号表）、语义分析（四元式生成）、目标代码生成

李若馨（组员）：文法设计和扩展、语法分析、四元式优化

朱哲萱（组员）：文法设计和扩展、词法分析、常数处理机

权凇（组员）：文法设计和扩展、界面设计、词法分析自动机设计、四元式优化

#### 1.4 任务模块划分

+ 文法设计和扩展
+ 创建符号表模块
+ 词法分析（含常数处理机）
+ 语法分析
+ 语义分析（填写符号表）
+ 语义分析（四元式生成）
+ 四元式优化
+ 目标代码生成
+ 错误处理

#### 1.5 说明

编译原理是计算机专业十分重要的一门学科，目的在于介绍编译程序构造的一般原理和基本方法，内容包括词法分析、语法分析、语法制导翻译、中间代码生成、中间代码优化和目标代码生成。学习编译原理这门课程，不仅仅可以深刻理解程序设计语言的设计和实现原理，而且在工作中往往可以类比这部分知识，设计新的领域专用语言及其编译器。而编译原理课程设计，是在理论学习上的实践，更够加强学生对这门课的认识以及对知识点的掌握，对学生起着非常重要的意义。

作为组长，我深知编译原理课设的难度，因此从一开始分工就是很慎重的。在一开始拿到老师给的pascal文法时，我不知所措，查阅了网上的一些资料之后，我觉得有必要对编译原理的知识进行梳理，然后才可以理解文法的重要性。因此，我又复习了一遍编译原理的基础知识，梳理了一下框架，从前端到后端，划分模块情况见1.4节。后来我明白，文法确实非常重要，没有文法可以写词法分析，但是离开了文法，语法分析，语义分析，都是没法做的，所以在设计文法时候，我们非常谨慎。

经过研究之后，我客观分析，两周不到的时间，以我的能力，我应该只能做一个简单文法编译器的设计和实现，之所以叫设计和实现，是因为文法是需要全组组员自行设计的，而实现是要参考文法来实现的。此外，还需要组员的密切协助，因此，我选用了C++语言来做C语言的编译器。一开始设计文法时候，我列举了一些C语言程序的情况，更容易理解文法的设计方法，然后设计了第一版本的文法，在后续程序设计的过程中，随着语法分析LL（1）方法的确定，文法也渐渐成熟。接下来的小节，我将分别从文法设计、词法分析、符号表填写和设计语法制导翻译的文法设计方面遇到的困难和解决问题的办法。

### 二、文法设计

经过文法的多次改造变换，最终成功变换成为LL(1)文法。

> **1.程序定义**
>
> <程序>-><函数>A1|struct标识符{K}<程序>47
>
> K-><变量声明>K48|空49
>
> A-><函数>A2|空3
>
> <函数> →  <类型><标识符>(){<复合语句>}4
>
>  
>
> **2.语句定义**
>
> <复合语句>-> <变量声明> <复合语句>5
>
> |<赋值语句> <复合语句>6
>
> |if(<判断语句>){<复合语句>}B7
>
> |while(<判断语句>){<复合语句>}<复合语句>37
>
> |<跳转语句><复合语句>10
>
> |空11
>
> B->else {<复合语句>}<复合语句>8|<复合语句>9
>
> <变量声明>-><类型><标识符表>12
>
> <赋值语句>-><标识符>G14
>
> G->=J43|[常数]=J44
>
> J-><算数表达式>；45|’字符’；46
>
> <标识符表>-><标识符>H15
>
> H->C38|[常数]；39|=I40
>
> I->’字符’；41|常数；42
>
> C->,<标识符表>16|；17
>
> <判断语句>-><算术表达式>D18
>
> D->ω2 <算术表达式>19|空20
>
> <跳转语句>->continue;21|break;22
>
>  
>
> **3.算数表达式定义**
>
> <算术表达式>-><项>E23
>
> E->ω0 <项>E24|空25      
>
> <项>-><因子>F26
>
> F->ω1<因子>F27|空28
>
> <因子>-><算术量> 29| ( <算术表达式> )30
>
> <算术量>-><标识符>31| <常数>32
>
>  
>
> **4.类型定义**
>
> <类型>->int33| float34| char35| void36
>
> 以下部分由词法分析来实现
>
>  
>
> **5.单词集定义**
>
> <标识符>-><字母> | <标识符> <数字> | <标识符> <字母>
>
> <常数>-><整数> | <实数>
>
> <整数>-><数字> | <整数> <数字>
>
> <实数>-><整数> . <整数>
>
>  
>
> **6.字符集定义**
>
> <字母>->A|B|C|…|Z|a|b|c|…|z
>
> <数字>->0|1|2|3|4|5|6|7|8|9
>
> 其中：ω0 — +或-
>
>    ω1 — *或/
>
> ω2 — >或>=或<或<=或==或||或&

### 三、词法分析

词法分析的难点主要在于函数的构造方法，如何使用自动机的思想来设计这个词法分析器的同时可以降低时间复杂度呢？可以就根据自动机的定义，用状态转换的方法，根据当前状态state和得到的字符ch来判断下一个state，同时用phrase来存放当前的字符，进而判别单词，每次判定完phrase ，压入vector类型的token序列中。至于关键字表KT和界符表PT，我们使用STL中的map，但是可能是C++版本的问题，VS不能运行map<int,string>定义的KT和PT表，因此我们的程序执行软件限制在了codeblocks上。另外，在词法分析中我们直接加入了可以处理整数、小数、指数的常数处理机，在朱哲萱的.md文件中有详细的数据结构和设计解释，此处不再赘述。

这个过程我们小组的主要完成方式是，权凇同学负责绘制和设计自动机，我负责数据结构和函数设计，朱哲萱负责具体的函数实现。

### 四、语法分析

语法分析的难点主要在于文法的设计，确定了LL（1）文法之后，我对文法进行了修改，使其满足LL（1）文法的要求，其中本文第二节文法是修改后的文法。在设计数据结构之前，将每一个文法符号全都转换成了int型的一个数据，进行了统一编码，其中终结符编码从0到33，非终结符编码从51到74，#的编码为100。采用较简单的数据结构就能完成较复杂编译程序的具体设计。然后求Select集合，具体的select表在下方。

这个过程我们小组的主要完成方式是，我负责修改文法和求select集合，李若馨负责具体的函数实现，函数具体实现环节，主要困难在于设计查分析表函数，利用Token_to_code函数把文法左端的符号都标记为数字，查select表，遇到select集合中的对应元素时候，返回值为分析表的值，根据这个状态，Search_LL1_Excel()函数把文法右端的符号逆序压栈，其他部分按照老师上课给的PPT里面的流程图就行了。

下面的两个大表格分别是每一个文法符号对应的编码表示和LL(1)文法对应的select表。

| 终结符 | 编码表示 | 非终结符 | 编码表示 |
| ------ | -------- | -------- | -------- |
| （     | 0        | 程序     | 51       |
| ）     | 1        | 函数     | 52       |
| {      | 2        | 类型     | 53       |
| }      | 3        | 复合语句 | 54       |
| 标识符 | 4        | 变量声明 | 55       |
| if     | 5        | 赋值语句 | 56       |
| else   | 6        | 判断语句 | 57       |
| =      | 7        | 跳转语句 | 58       |
| ,      | 8        | 标识符表 | 59       |

| 终结符   | 编码表示 | 非终结符   | 编码表示 |
| -------- | -------- | ---------- | -------- |
| ;        | 9        | 算数表达式 | 60       |
| +        | 10       | 项         | 61       |
| -        | 11       | 因子       | 62       |
| *        | 12       | 算数量     | 63       |
| /        | 13       | A          | 64       |
| 常量     | 14       | B          | 65       |
| int      | 15       | C          | 66       |
| float    | 16       | D          | 67       |
| char     | 17       | E          | 68       |
| void     | 18       | F          | 69       |
| >        | 19       | G          | 70       |
| <        | 20       | H          | 71       |
| ==       | 21       | I          | 72       |
| >=       | 22       | J          | 73       |
| <=       | 23       | K          | 74       |
| \|\|     | 24       |            |          |
| &&       | 25       |            |          |
| #        | 100      |            |          |
| continue | 26       |            |          |
| break    | 27       |            |          |
| while    | 28       |            |          |
| 字符     | 29       |            |          |
| [        | 30       |            |          |
| ]        | 31       |            |          |

| 终结符 | 编码表示 | 非终结符 | 编码表示 |
| ------ | -------- | -------- | -------- |
| ‘      | 32       |          |          |
| struct | 33       |          |          |

select表：

|            | (    | )    | {    | }    | 标识符 | if   | else | =    | ,    |
| ---------- | ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ---- |
| 程序       |      |      |      |      |        |      |      |      |      |
| A          |      |      |      |      |        |      |      |      |      |
| 函数       |      |      |      |      |        |      |      |      |      |
| 复合语句   |      |      |      | 11   | 6      | 7    |      |      |      |
| B          |      |      |      |      |        |      | 8    |      |      |
| 变量声明   |      |      |      |      |        |      |      |      |      |
| 赋值语句   |      |      |      |      | 14     |      |      |      |      |
| 标识符表   |      |      |      |      | 15     |      |      |      |      |
| C          |      |      |      |      |        |      |      |      | 16   |
| 判断语句   | 18   |      |      |      | 18     |      |      |      |      |
| D          |      | 20   |      |      |        |      |      |      |      |
| 跳转语句   |      |      |      |      |        |      |      |      |      |
| 算术表达式 | 23   |      |      |      | 23     |      |      |      |      |
| E          |      | 25   |      |      |        |      |      |      |      |
| 项         | 26   |      |      |      | 26     |      |      |      |      |
| F          |      | 28   |      |      |        |      |      |      |      |
| 因子       | 30   |      |      |      | 29     |      |      |      |      |
| 算术量     |      |      |      |      | 31     |      |      |      |      |
| 类型       |      |      |      |      |        |      |      |      |      |
| G          |      |      |      |      |        |      |      | 43   |      |
| H          |      |      |      |      |        |      |      | 40   | 38   |
| I          |      |      |      |      |        |      |      |      |      |
| J          | 45   |      |      |      | 45     |      |      |      |      |
| K          |      |      |      | 49   |        |      |      |      |      |

|            | ;    | +    | -    | *    | /    | >    | <    | ==   | >=   | <=   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 程序       |      |      |      |      |      |      |      |      |      |      |
| A          |      |      |      |      |      |      |      |      |      |      |
| 函数       |      |      |      |      |      |      |      |      |      |      |
| 复合语句   |      |      |      |      |      |      |      |      |      |      |
| B          |      |      |      |      |      |      |      |      |      |      |
| 变量声明   |      |      |      |      |      |      |      |      |      |      |
| 赋值语句   |      |      |      |      |      |      |      |      |      |      |
| 标识符表   |      |      |      |      |      |      |      |      |      |      |
| C          | 17   |      |      |      |      |      |      |      |      |      |
| 判断语句   |      |      |      |      |      |      |      |      |      |      |
| D          |      |      |      |      |      | 19   | 19   | 19   | 19   | 19   |
| 跳转语句   |      |      |      |      |      |      |      |      |      |      |
| 算术表达式 |      |      |      |      |      |      |      |      |      |      |
| E          | 25   | 24   | 24   |      |      | 25   | 25   | 25   | 25   | 25   |
| 项         |      |      |      |      |      |      |      |      |      |      |
| F          | 28   | 28   | 28   | 27   | 27   | 28   | 28   | 28   | 28   | 28   |
| 因子       |      |      |      |      |      |      |      |      |      |      |
| 算术量     |      |      |      |      |      |      |      |      |      |      |
| 类型       |      |      |      |      |      |      |      |      |      |      |
| G          |      |      |      |      |      |      |      |      |      |      |
| H          | 38   |      |      |      |      |      |      |      |      |      |
| I          |      |      |      |      |      |      |      |      |      |      |
| J          |      |      |      |      |      |      |      |      |      |      |
| K          |      |      |      |      |      |      |      |      |      |      |

|            | \|\| | &&   | 常数 | int  | float | char | void | while |
| ---------- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ----- |
| 程序       |      |      |      | 1    | 1     | 1    | 1    |       |
| A          |      |      |      | 2    | 2     | 2    | 2    |       |
| 函数       |      |      |      | 4    | 4     | 4    | 4    |       |
| 复合语句   |      |      |      | 5    | 5     | 5    | 5    | 37    |
| B          |      |      |      | 9    | 9     | 9    | 9    |       |
| 变量声明   |      |      |      | 12   | 12    | 12   | 12   |       |
| 赋值语句   |      |      |      |      |       |      |      |       |
| 标识符表   |      |      |      |      |       |      |      |       |
| C          |      |      |      |      |       |      |      |       |
| 判断语句   |      |      | 18   |      |       |      |      |       |
| D          | 19   | 19   |      |      |       |      |      |       |
| 跳转语句   |      |      |      |      |       |      |      |       |
| 算术表达式 |      |      | 23   |      |       |      |      |       |
| E          | 25   | 25   |      |      |       |      |      |       |
| 项         |      |      | 26   |      |       |      |      |       |
| F          | 28   | 28   |      |      |       |      |      |       |
| 因子       |      |      | 29   |      |       |      |      |       |
| 算术量     |      |      | 32   |      |       |      |      |       |
| 类型       |      |      |      | 33   | 34    | 35   | 36   |       |
| G          |      |      |      |      |       |      |      |       |
| H          |      |      |      |      |       |      |      |       |
| I          |      |      | 42   |      |       |      |      |       |
| J          |      |      | 45   |      |       |      |      |       |
| K          |      |      |      | 48   | 48    | 48   | 48   |       |

|            | continue | break | 字符 | [    | ]    | ‘    | #    |
| ---------- | -------- | ----- | ---- | ---- | ---- | ---- | ---- |
| 程序       |          |       |      |      |      |      |      |
| A          |          |       |      |      |      |      | 3    |
| 函数       |          |       |      |      |      |      |      |
| 复合语句   | 10       | 10    |      |      |      |      |      |
| B          |          |       |      |      |      |      |      |
| 变量声明   |          |       |      |      |      |      |      |
| 赋值语句   |          |       |      |      |      |      |      |
| 标识符表   |          |       |      |      |      |      |      |
| C          |          |       |      |      |      |      |      |
| 判断语句   |          |       |      |      |      |      |      |
| D          |          |       |      |      |      |      |      |
| 跳转语句   | 21       | 22    |      |      |      |      |      |
| 算术表达式 |          |       |      |      |      |      |      |
| E          |          |       |      |      |      |      |      |
| 项         |          |       |      |      |      |      |      |
| F          |          |       |      |      |      |      |      |
| 因子       |          |       |      |      |      |      |      |
| 算术量     |          |       |      |      |      |      |      |
| 类型       |          |       |      |      |      |      |      |
| G          |          |       |      | 44   |      |      |      |
| H          |          |       |      | 39   |      |      |      |
| I          |          |       |      |      |      | 41   |      |
| J          |          |       |      |      |      | 46   |      |
| K          |          |       |      |      |      |      |      |

在此需要声明的是，在循环语句处理时候，我们没有处理for语句 ；条件语句判断时候，我们没有设计switch-case语句。

### 五、词法分析填写符号表

定义符号表的部分，我使用了class定义，内部数据有的使用了STL的vector定义，未使用的以vector<class>  x的形式定义符号表。符号表中的每个表都对应一个特定的类，表中的元素也与类中的成员一一对应。为实现列表的结构，使得类中的成员均是vector容器，vector容器的下标对应表中的行数。对于表中的指针成员，均用vector<int>建立，其内容为其指向的符号表的对象下表，以此达到指针效果。另使用vector容器结构易于管理，不会出现使用指针时指向不知名存储单元的事，而且vector容器删除成员也很容易。

**功能：**

将法分析识别到的标识符、常数、字符和字符串填入符号表：

标识符：填入符号总表		常数：填入常数表		字符：填入字符表		字符串：填入字符串表

**结构表 RINFL**

|  string  | int  |      int       |
| :------: | :--: | :------------: |
|    id    | off  |       tp       |
| 结构域名 | 区距 | 域成分类型指针 |

**函数表 PFINFL**

|  int   | int  |   int    |  int   |
| :----: | :--: | :------: | :----: |
| level  | off  |    fn    | entry  |
| 层次号 | 区距 | 参数个数 | 参数表 |

**数组表 AINFL**

|   int    |   int    |     int      |      int       |
| :------: | :------: | :----------: | :------------: |
|   low    |    up    |     ctp      |      clen      |
| 数组下界 | 数组上界 | 成分类型指针 | 成分类型的长度 |

**类型表 TAPEL**

|  string  |                                                      |
| :------: | :--------------------------------------------------: |
|   tval   |                                                      |
| 类型代码 | **i整型  r实型  c字符型  b布尔型  a数组型  d结构型** |

**符号表总表 SYNBL**

| string | string | int  | string |
| :----: | :----: | :--: | :----: |
|  name  |  cat   | typ  | adder  |
|  名字  |  类型  | 种类 |  地址  |

+ 以填写符号表中的char类型字符为例，已知bool IsChar为true，先把IsChar状态改为false，然后用class token类定义的对象tk，调用里面构造的setToken函数，把符号表里面的Table_cat和Table_key填进去，phrase应该是存储当前的一个token串的，在确定了是字符的情况下，我读到了a/b/c/d... ，只有phrase[0]一个地方有字符，所以就把这个字符给c_value，这就是char类型字符的词法分析填写符号表。
+ 字符串类型同理，修改IsString的状态，然后把存放在phrase中的现有的Token串给s_value，这里的s_value是个字符串，必须整个用push_back的方法加入到字符串表中。
+ 判断是否是关键字可以看phrase的第一个字符，如果是英文字母，则首先假定他是一个关键字而不是标识符，然后在关键字的数组中查找它，如果查到了，说明是关键字，写入到Token串当中；如果查不到，说明是标识符，进入标识符判断模块。
+ 如果是标识符，首先要判断它是否在已有标识符内，如果已经存在了，就写入Token串即可；如果不存在，不仅要写入Token串，还要把加到符号表中，并对表尾指针加一。
+ 如果是常数，先处理常数处理机的情况，首先处理指数1.2e^-3^和1.2e^3^两种情况，然后处理小数和整数的情况。
+ 界符在最后处理，用push_back函数，把符号写进界符表中。

实验当中的词法分析和语法分析是紧密结合的，但是在课程设计中，词法分析也要和符号表紧密结合，才能顺利完成语义分析。

词法分析填写符号表的难点在于如何和词法分析有机结合，好在定义KT表和PT表的数据结构的时候我和队友有过协商，虽然完成了填写，但是我不确定是否仍然潜伏的逻辑bug。

### 六、语义分析符号表

语义分析是在语法分析的过程中加入某些操作，即插入一些语义动作来解决问题，这就是语法制导翻译技术。语法制导是指根据语言的形式文法对输入序列进行分析、翻译处理。

语法制导翻译器可以描述为“扩展的语法分析器+翻译文法”。其中，自顶向下的翻译文法要求：

⑴ 源文法应满足自顶向下分析要求(如 LL(1)文法)；

⑵ 属性是自顶向下可求值的(属性计算不发生冲突)；

⑶ 动作符号可插入到产生式右部任何位置。

由于我们采用的是自顶向下的LL(1)分析法，所以具体来讲LL(1)语法分析器需要做以下扩展：

⑴ 当产生式(逆序)压栈时，动作符号也不例外；

⑵ 当动作符号位于栈顶时，执行之。

符号总表：

```C++
string Name[50];//用来存储符号总表中标识符名字
string Type[50];//用来存储符号总表中标识符数据类型
string Cat[50];//用来存储符号总表中标识符的种类
int Address[50];//用来存储符号总表中标识符的值单元相关信息
string L[50];//用来存储符号总表中标识符的初始活跃信息
```

数组表：

```C++
int Low[50];//用来存储数组表中下界信息
string Up[50];//用来存储数组表中上界信息
string Ctp[50];//用来存储数组表中数组成分类型
int Clen[50];//用来存储数组表中每个数组成分所占空间
```

结构体表：

```C++
string ID[50];//用来存储结构体表中的域名
int OFF[50];//用来存储结构体表中的各个域的偏移量
string TP[50];//用来存储结构体表中的各个域的数据类型
```

分工情况是我来做符号表的填写，目前还没有完成，程序出现很多bug，先不放代码，预计7月6日上机之前可以做完符号表的填写。

### 七、语义分析四元式

同语义分析之生成符号表模块一样，语义分析之生成四元式是在语法分析的过程中加入某些操作，即插入一些语义动作来解决问题，这就是语法制导翻译技术。

我们采用的是四元式形式的中间语言，具体生成了算数表达式四元式，赋值四元式，if|else 四元式和循环四元式等，为接下来的优化和目标代码的生成做好了准备。

语义分析四元式部分，我定义了一个数组，用压栈的方法，定义了GEQ函数，ASSI函数，POPSEM函数和PUSHSEM函数。

分工情况是文法设计和组员一起探究讨论，实现部分由我来完成，工作时间是和词法分析、语法分析并行的，但是因为没有衔接，只能写一部分基本框架，并不能验证正确性，代码如下：

```c++
void GEQ(string Operator,int label);
void PUSHSEM(string push_str);
void POPSEM();
void ASSI();

string dest[1000];
int SP=0;
void IF(){
    dest[ge++]="if";
    dest[ge++]=SEM[SP-1];
    dest[ge++]="_";
    dest[ge++]="_";

    POPSEM();
}

void EL(){
    dest[ge++]="el";
    dest[ge++]="_";
    dest[ge++]="_";
    dest[ge++]="_";
}

void IE(){
    dest[ge++]="ie";
    dest[ge++]="_";
    dest[ge++]="_";
    dest[ge++]="_";
}

void WH(){
    dest[ge++]="wh";
    dest[ge++]="_";
    dest[ge++]="_";
    dest[ge++]="_";
}

void DO(){
    dest[ge++]="do";
    dest[ge++]=SEM[SP-1];
    dest[ge++]="_";
    dest[ge++]="_";

    POPSEM();
}

void WE(){
    dest[ge++]="we";
    dest[ge++]="_";
    dest[ge++]="_";
    dest[ge++]="_";
}
string tempValue[50]={"t1","t2","t3","t4","t5","t6","t7","t8","t9","t10","t11","t12","t13","t14","t15","t16","t17","t18","t19","t20"};
void GEQ(string Operator,int label){

    dest[ge++]=Operator;
    dest[ge++]=SEM[SP-2];
    dest[ge++]=SEM[SP-1];
    dest[ge++]=tempValue[label];

    Current_Type="int";
    WRITE_SYNBL(tempValue[label],"n");

    POPSEM();
    POPSEM();
    PUSHSEM(tempValue[label]);

}

void ASSI(){

    if(ArraySem_Address==0){
         dest[ge++]="=";
         dest[ge++]=SEM[SP-1];
         dest[ge++]="_";
         dest[ge++]=SEM[SP-2];

         POPSEM();
         POPSEM();
    }
    else{
         dest[ge++]="=";
         dest[ge++]=SEM[SP-1];
         dest[ge++]="_";
         dest[ge++]=SEM[SP-2]+"["+ArraySem[ArraySem_Address-1]+"]";

         ArraySem_Address--;

         POPSEM();
         POPSEM();
    }
}
void PUSHSEM(string push_str){
    SEM[SP]=push_str;
    SP++;
}

void POPSEM(){
    SP--;
}
```

### 八、下一步工作：

这一段时间我们的工作主要还是聚焦于前端，一开始听了张俐老师的话，并没有把摊子铺开铺大，个人觉得设计的规模还算可以，虽然可能照比其他组我们的进度不算快的，但是已经写好的代码基本没有bug了，而且文法设计基本完成，我们组的基础很好，这为后期调试节省了很多时间。预计在7月4日至7月7日左右，我的工作量会比较大，接下来几天我主要负责四元式生成和目标代码生成，为了让队友更好的理解后端，我让李若馨和权凇两位同学一起来回顾DAG部分的知识，我们三个人一起讨论，做四元式的优化部分。最后目标代码生成部分，由我完成。
